# Image Traffic Profile — Modal Prefetch Buffer

Analysis of network traffic generated by the gallery thumbnail system and the modal
circular prefetch buffer introduced in `feat/modal-prefetch`.

---

## Asset sizes (estimated)

| Asset | Endpoint | Typical size |
|-------|----------|-------------|
| Thumbnail | `GET /api/executions/{id}/thumbnail` | ~8 KB (200 px WebP, 70 % quality) |
| Full image | `GET /api/executions/{id}/image/webp` | ~300 KB (full-res WebP, 80 % quality) |

Actual sizes vary by scene complexity. 300 KB is a reasonable median for compressed
1080 p surveillance frames; low-activity frames can be 80–120 KB.

---

## Caching gap — applies to all phases

Three independent factors disable HTTP caching for every image request:

1. **`Authorization` header on every fetch** — the response is private, the browser will
   not cache it without an explicit `Cache-Control: private, max-age=…`.
2. **Server sends no `Cache-Control`** on `/image/webp` or `/thumbnail` endpoints.
3. **`usePrefetchBuffer` sends no `If-None-Match`** — no conditional-GET support, even
   if ETags were present.

Result: every image fetch is a full round-trip. The same image can be downloaded
multiple times in the same browser session.

---

## Phase 1 — Gallery page load (thumbnail strip)

`useSecureImage` fetches a blob URL for each visible card.

```
50 thumbnails × 8 KB ≈ 400 KB per page
```

`loadMore` fires when the selected execution reaches ≤ 10 positions before the end of
the loaded list. Each page load adds ~400 KB of thumbnails regardless of which camera
or filter is active.

**List view vs grid view:** cost is identical — same thumbnails, same hook.

---

## Phase 2A — Modal open in Gallery mode

On open the prefetch buffer fires a burst for the whole initial window:

| FPS setting | Lookahead | Window | Burst |
|-------------|-----------|--------|-------|
| 3 fps | ±5 | 11 images | **~3.3 MB** |
| 10 fps (default) | ±12 | 25 images | **~7.5 MB** |
| 20 fps | ±25 | 51 images | **~15 MB** |

Images are fetched concurrently (no queue depth limit). Only executions with
`hasImage = true` are included; sparse datasets reduce the actual cost proportionally.

`galleryNav` is ordered newest-first (descending index), so the ±N window spans
images that are both newer (lower array index) and older (higher array index) than
the current one.

---

## Phase 2B — Modal open in Camera mode

Camera mode (`cameraNav`) operates on a **subset** of the already-loaded gallery
executions: only siblings that share the same `cameraId`, sorted chronologically
(ascending, oldest-first).

### Initial window cost

Same lookahead formula as gallery mode, but applied to the camera-sibling array:

| FPS | Window | Cost if siblings have images |
|-----|--------|------------------------------|
| 3 fps | ±5 = 11 | ~3.3 MB |
| 10 fps | ±12 = 25 | ~7.5 MB |
| 20 fps | ±25 = 51 | **up to ~15 MB** — capped by sibling count |

If the camera has fewer than 2×lookahead+1 siblings in the loaded set, the window is
smaller and the burst is proportionally cheaper.

### Progressive sibling discovery (both-ends `loadMore`)

Camera siblings are derived from the gallery `executions` array. As the user navigates
toward either chronological boundary the `useEffect` in `ImageGallery` calls
`loadMore()` when:

```
cameraNav.index ≥ cameraNav.total - 5   (near the "new" end)
cameraNav.index ≤ 4                     (near the "old" end)
```

Each `loadMore` fetches the next gallery page (50 executions ordered by
`execution_timestamp DESC`). Those 50 executions are primarily from **all** cameras,
not filtered to the active one. Expected sibling yield depends on how frequently the
active camera fires:

| Camera firing rate | New siblings per page load | Wasted thumbnails |
|--------------------|---------------------------|-------------------|
| 1 in 5 executions | ~10 new siblings | ~40 thumbnails (~320 KB) |
| 1 in 20 executions | ~2–3 new siblings | ~47 thumbnails (~376 KB) |
| Exclusive (all from this camera) | ~50 new siblings | 0 KB wasted |

This is the main inefficiency of camera mode at low firing rates: the user triggers
a 400 KB page load to gain 2–3 new full-image prefetches (~600–900 KB useful), with
the rest of the thumbnail cost being overhead.

### Direction asymmetry

- **Right arrow (newer)** — navigates toward `idx - 1` in the descending gallery
  array; `loadMore` fires when within 5 positions of the "new" end because more
  recent siblings may not be loaded yet.
- **Left arrow (older)** — navigates toward `idx + 1`; `loadMore` fires when within 5
  positions of the "old" end. However, `loadMore` always fetches the *next* page
  (older executions), so going older is served first and will exhaust pagination
  naturally. Going newer can stall if the most recent siblings have already scrolled
  off the top of the loaded window (unlikely in practice because the gallery opens
  with newest-first data).

---

## Phase 3 — Sustained navigation (held arrow key)

Each step slides the buffer window by 1:

```
net per step = 1 fetch (entering) + 1 eviction (leaving, blob URL revoked)
             = ~300 KB
```

| FPS | Steps/sec | Sustained bandwidth |
|-----|-----------|---------------------|
| 3 fps | 3 | ~0.9 MB/s = ~54 MB/min |
| 10 fps (default) | 10 | ~3 MB/s = ~180 MB/min |
| 20 fps | 20 | ~6 MB/s = ~360 MB/min |

**Buffer race condition.** The buffer wins if network fetch time < step interval:

| Connection | 300 KB fetch time | Max safe FPS |
|------------|-------------------|--------------|
| 100 Mbps LAN | ~24 ms | 20 fps (50 ms/step) ✓ |
| 50 Mbps | ~48 ms | 20 fps (50 ms/step) marginal |
| 10 Mbps | ~240 ms | 3 fps (333 ms/step) ✓, 10 fps may show spinners |
| 4 Mbps (4G) | ~600 ms | 3 fps possible if scene is not dense; 10+ fps will lag |

---

## Phase 4 — Modal close / reopen

`prefetch([])` is called on close: every cached blob URL is revoked and the entries
are deleted. Reopening the same execution (or any nearby execution) triggers a full
Phase 2 burst again.

**There is no persistent cross-session cache.** The same image costs the same whether
it has been viewed 1 or 10 times in the current browser tab.

---

## Aggregate scenario: 5-minute browsing session at 10 fps

```
Gallery initial load (1 page thumbnails):   ~400 KB
Modal open burst (Gallery mode, 10 fps):    ~7.5 MB
Navigation 5 min × 10 fps:                 ~90 MB   (600 net-new images × 300 KB)
loadMore pages triggered (≈ 3):             ~1.2 MB  (3 pages × 400 KB thumbnails)
─────────────────────────────────────────────────────
Total:                                     ~99 MB
```

At 20 fps this roughly doubles to ~200 MB. At 3 fps it falls to ~20 MB.

Camera mode adds ~1–5 extra `loadMore` calls depending on camera sparsity, but
navigation cost per step is identical.

---

## Quick wins if bandwidth is a constraint

| Change | Mechanism | Estimated saving |
|--------|-----------|-----------------|
| `Cache-Control: private, max-age=300` on image endpoints | 5-min TTL; reopening the same modal session costs ~0 KB instead of the full burst | 50–80 % reduction on revisit |
| Keep buffer alive across modal close (don't call `prefetch([])`) | Reopen is free if same neighborhood | 100 % on immediate reopen |
| Add `ETag` + `If-None-Match` in `usePrefetchBuffer` | 304 Not Modified = headers only (~200 B) | Significant for slow connections |
| Camera-aware `loadMore` filter | Request only executions from the active camera | Eliminates thumbnail overhead for low-frequency cameras |
| Adaptive lookahead based on connection speed | Use `navigator.connection.downlink` to cap window | Prevents burst overrun on slow links |
